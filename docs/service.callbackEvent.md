# Service: Callback Event Bridge

Source: [`src/util/service.callbackEvent.js`](../src/util/service.callbackEvent.js)

This module implements a communication bridge between the Page Context (code running on the page) and the Content Context (the extension content script) using `CustomEvent` and a shared token stored in `document.documentElement.dataset`.

It allows you to:
- Register callbacks in the content script grouped by `command` and `action`.
- Invoke them from the page with arguments and receive a typed asynchronous response.

It is used in the project to expose, for example, the commands:
- `ptre.galaxy(changes, ptreKey?, serverTime?)`
- `messages.expeditionType(message)`

See the real registration in `src/ctxcontent/index.js` and its consumption in `src/ogkush.js` and `src/ctxpage/messages-analyzer/index.js`.

---

## Public API

Relevant types:
- RequestCallbackEvent
  - `referer: string` – unique request identifier (includes `command.action`).
  - `command: string` – command group.
  - `action: string` – action name within the group.
  - `args: any[]` – function arguments (must be serializable/cloneable).
- ResponseCallbackEvent
  - `success: boolean` – indicates whether the execution was successful.
  - `referer: string` – same request identifier.
  - `response: any` – result returned by the callback (or an error message).

Exported functions:

1) `contentContextInit(callbackCommandMap: { [command: string]: { [action: string]: Function } })`
- Context: Content script (`chrome.runtime` must exist).
- Effect: Generates a random token and publishes it in `data-ogiCallbackEventToken`. Listens for request events and replies with events keyed by the request "referer".
- Errors that can be thrown:
  - "Invalid context execution" if not running in a content script.
  - "service callback event is already initialized" if it has already been initialized.

2) `pageContextInit()`
- Context: Page (MUST NOT have `window.chrome.runtime`).
- Effect: Reads the `data-ogiCallbackEventToken` generated by the content script and enables sending requests from the page.
- Errors that can be thrown:
  - "Invalid context execution" if executed in an extension context.
  - "service callback event is not initialized" if the content script has not initialized the service yet.

3) `pageContextRequest(command: string, action: string, ...args: any[]): Promise<ResponseCallbackEvent>`
- Sends the request to the content script and waits for a response with the same `referer`.
- Promise behavior:
  - RESOLVES with `ResponseCallbackEvent` if `success === true`.
  - REJECTS with `ResponseCallbackEvent` if `success === false` (e.g., unknown command/action or an exception thrown by the callback).

Compatibility notes:
- Firefox: the response is cloned with `cloneInto` to avoid cross-compartment issues between contexts.

---

## Internal flow (high level)
1. The content script calls `contentContextInit({...})` and publishes a token in `document.documentElement.dataset.ogiCallbackEventToken`.
2. The page calls `pageContextInit()`; if the token exists, the bridge is enabled.
3. The page calls `pageContextRequest("command", "action", ...args)`, creating a unique `referer` and dispatching a `CustomEvent` named `ogiCallbackEventToken<TOKEN>`.
4. The content script resolves the action and responds with a `CustomEvent` `ogiCallbackEventToken<TOKEN>-<referer>` where `detail` is the `ResponseCallbackEvent`.
5. The page listens for that `referer` with `{ once: true }` and either resolves or rejects the promise.

Events/Token:
- Dataset key: `ogiCallbackEventToken` (in `document.documentElement.dataset`).
- Request event: `ogiCallbackEventToken${TOKEN}`.
- Response event: `ogiCallbackEventToken${TOKEN}-${referer}`.
- `referer` format: `<hex>[command.action]`.

Limitations:
- The arguments of `pageContextRequest` must be cloneable/serializable data (no functions, no non-cloneable DOM references, etc.).

---

## Typical usage

### In the content script (registering actions)
```ts
import { contentContextInit } from "../util/service.callbackEvent.js";
import { getExpeditionType } from "./callbacks/expedition-type.js";

contentContextInit({
  ptre: {
    galaxy(changes, ptreKey = null, serverTime = null) {
      // return a Promise or a value; it will be handled as async
      return dataHelper.scan(changes, ptreKey, serverTime);
    },
  },
  messages: {
    expeditionType: getExpeditionType,
  },
});
```

### On the page (consuming)
```ts
import { pageContextInit, pageContextRequest } from "../util/service.callbackEvent.js";

pageContextInit();

// Example: get expedition type
try {
  const { response } = await pageContextRequest("messages", "expeditionType", rawMessage);
  console.log(response.type); // string
} catch (err) {
  // err is also a ResponseCallbackEvent; e.g., unregistered command/action
  console.error("ExpeditionType error:", err.response);
}

// Example: PTRE scanner
await pageContextRequest("ptre", "galaxy", changes, ptreKey, serverTime);
```

---

## Relation with existing documentation
The file `docs/context.content.commands.md` lists the exposed commands and shows invocation examples. That documentation is correct regarding commands and arguments for:
- `ptre.galaxy(changes, ptreKey?, serverTime?)`
- `messages.expeditionType(message)` which returns `{ type: string, busy: boolean }` (this last flag is currently always `false`).

Additional clarifications worth noting (that were not detailed there):
- You must call `pageContextInit()` on the page before using `pageContextRequest`.
- The `pageContextRequest` promise is REJECTED when `success === false`.
